(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{605:function(s,n,a){"use strict";a.r(n);var t=a(6),r=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("Lua 字符串库包含很多强大的字符操作函数。字符串库中的所有函数都导出在模块 string 中。在 Lua 5.1 中，它还将这些函数导出作为 string 类型的方法。这样假设要返回一个字符串转的大写形式，可以写成 ans = string.upper(s) ,也能写成 ans = s:upper()。为了避免与之前版本不兼容，此处使用前者。\nLua 字符串总是由字节构成的。Lua 核心并不尝试理解具体的字符集编码（比如 GBK 和 UTF-8 这样的多字节字符编码）。\n需要特别注意的一点是，"),a("strong",[s._v("Lua 字符串内部用来标识各个组成字节的下标是从 1 开始的")]),s._v("，这不同于像 C 和 Perl 这样的编程语言。这样数字符串位置的时候再也不用调整，对于非专业的开发者来说可能也是一个好事情，string.sub(str, 3, 7) 直接表示从第三个字符开始到第七个字符（含）为止的子串。")]),s._v(" "),a("h4",{attrs:{id:"string-byte-s-i-j"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-byte-s-i-j"}},[s._v("#")]),s._v(" string.byte(s[,i[,j]])")]),s._v(" "),a("p",[s._v("返回字符 "),a("code",[s._v("s[i]、s[i + 1]、s[i + 2]、······、s[j]")]),s._v(" 所对应的 ASCII 码。i 的默认值为 1，即第一个字节,j 的默认值为 i 。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.byte("abc", 1, 3))\nprint(string.byte("abc", 3)) -- 缺少第三个参数，第三个参数默认与第二个相同，此时为 3\nprint(string.byte("abc"))    -- 缺少第二个和第三个参数，此时这两个参数都默认为 1\n\n--\x3eoutput\n97    98    99\n99\n97\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("由于 string.byte 只返回整数，而并不像 string.sub 等函数那样（尝试）创建新的 Lua 字符串， 因此使用 string.byte 来进行字符串相关的扫描和分析是最为高效的，尤其是在被 LuaJIT 2 所 JIT 编译之后。")]),s._v(" "),a("h4",{attrs:{id:"string-char"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-char"}},[s._v("#")]),s._v(" string.char (...)")]),s._v(" "),a("p",[s._v("接收 0 个或更多的整数（整数范围 ：0~255）,返回这些整数所对应的 ASCII 码字符组成的字符串。当参数为空时，默认是一个 0。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("print(string.char(96, 97, 98))\nprint(string.char())        -- 参数为空，默认是一个0，\n                            -- 你可以用string.byte(string.char())测试一下\nprint(string.char(65, 66))\n\n--\x3e output\n`ab\n\nAB\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("此函数特别适合从具体的字节构造出二进制字符串。这经常比使用 table.concat 函数和 .. 连接运算符更加高效。")]),s._v(" "),a("h4",{attrs:{id:"string-upper-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-upper-s"}},[s._v("#")]),s._v(" string.upper(s)")]),s._v(" "),a("p",[s._v("接收一个字符串 s，返回一个把所有小写字母变成大写字母的字符串。")]),s._v(" "),a("h4",{attrs:{id:"string-lower-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-lower-s"}},[s._v("#")]),s._v(" string.lower(s)")]),s._v(" "),a("p",[s._v("接收一个字符串 s，返回一个把所有大写字母变成小写字母的字符串。")]),s._v(" "),a("h4",{attrs:{id:"string-len-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-len-s"}},[s._v("#")]),s._v(" string.len(s)")]),s._v(" "),a("p",[s._v("接收一个字符串，返回它的长度。")]),s._v(" "),a("p",[s._v("使用此函数是不推荐的。应当总是使用` # 运算符来获取 Lua 字符串的长度\n由于 Lua 字符串的长度是专门存放的，并不需要像 C 字符串那样即时计算，因此获取字符串长度的操作总是 O(1) 的时间复杂度。")]),s._v(" "),a("h4",{attrs:{id:"string-find-s-p-init-plain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-find-s-p-init-plain"}},[s._v("#")]),s._v(" string.find(s, p [, init [, plain]])")]),s._v(" "),a("p",[s._v("在 s 字符串中第一次匹配 p 字符串。若匹配成功，则返回 p 字符串在 s 字符串中出现的开始位置和结束位置；若匹配失败，则返回 nil。 第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p 。 第四个参数默认为 false，当其为 true 时，只会把 p 看成一个字符串对待。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('local find = string.find\nprint(find("abc cba", "ab"))\nprint(find("abc cba", "ab", 2))     -- 从索引为2的位置开始匹配字符串：ab\nprint(find("abc cba", "ba", -1))    -- 从索引为7的位置开始匹配字符串：ba\nprint(find("abc cba", "ba", -3))    -- 从索引为6的位置开始匹配字符串：ba\nprint(find("abc cba", "(%a+)", 1))  -- 从索引为1处匹配最长连续且只含字母的字符串\nprint(find("abc cba", "(%a+)", 1, true)) --从索引为1的位置开始匹配字符串：(%a+)\n\n--\x3eoutput\n1   2\nnil\nnil\n6   7\n1   3   abc\nnil\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("对于 LuaJIT 这里有个性能优化点，对于 string.find 方法，当只有字符串查找匹配时，是可以被 JIT 编译器优化的，有关 JIT 可以编译优化清单，大家可以参考 "),a("a",{attrs:{href:"http://wiki.luajit.org/NYI",target:"_blank",rel:"noopener noreferrer"}},[s._v("http://wiki.luajit.org/NYI"),a("OutboundLink")],1),s._v(" ，性能提升是非常明显的，通常是 100 倍量级。 这里有个的例子，大家可以参考 https://groups.google.com/forum/m/#!topic/openresty-en/rwS88FGRsUI。")]),s._v(" "),a("h4",{attrs:{id:"string-format-formatstring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-format-formatstring"}},[s._v("#")]),s._v(" string.format(formatstring, ...)")]),s._v(" "),a("p",[s._v("按照格式化参数 formatstring，返回后面 ... 内容的格式化版本。编写格式化字符串的规则与标准 c 语言中 printf 函数的规则基本相同：它由常规文本和指示组成，这些指示控制了每个参数应放到格式化结果的什么位置，及如何放入它们。一个指示由字符 % 加上一个字母组成，这些字母指定了如何格式化参数，例如 d 用于十进制数、x 用于十六进制数、o 用于八进制数、f 用于浮点数、s 用于字符串等。在字符%和字母之间可以再指定一些其他选项，用于控制格式的细节。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.format("%.4f", 3.1415926))     -- 保留4位小数\nprint(string.format("%d %x %o", 31, 31, 31))-- 十进制数31转换成不同进制\nd = 29; m = 7; y = 2015                     -- 一行包含几个语句，用；分开\nprint(string.format("%s %02d/%02d/%d", "today is:", d, m, y))\n\n--\x3eoutput\n3.1416\n31 1f 37\ntoday is: 29/07/2015\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h4",{attrs:{id:"string-match-s-p-init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-match-s-p-init"}},[s._v("#")]),s._v(" string.match(s, p [, init])")]),s._v(" "),a("p",[s._v("在字符串 s 中匹配（模式）字符串 p，若匹配成功，则返回目标字符串中与模式匹配的子串；否则返回 nil。第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.match("hello lua", "lua"))\nprint(string.match("lua lua", "lua", 2))  --匹配后面那个lua\nprint(string.match("lua lua", "hello"))\nprint(string.match("today is 27/7/2015", "%d+/%d+/%d+"))\n\n--\x3eoutput\nlua\nlua\nnil\n27/7/2015\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("string.match 目前并不能被 JIT 编译，应 尽量 使用 ngx_lua 模块提供的 ngx.re.match 等接口。")]),s._v(" "),a("h4",{attrs:{id:"string-gmatch-s-p"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-gmatch-s-p"}},[s._v("#")]),s._v(" string.gmatch(s, p)")]),s._v(" "),a("p",[s._v("返回一个迭代器函数，通过这个迭代器函数可以遍历到在字符串 s 中出现模式串 p 的所有地方。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('s = "hello world from Lua"\nfor w in string.gmatch(s, "%a+") do  --匹配最长连续且只含字母的字符串\n    print(w)\nend\n\n--\x3eoutput\nhello\nworld\nfrom\nLua\n\n\nt = {}\ns = "from=world, to=Lua"\nfor k, v in string.gmatch(s, "(%a+)=(%a+)") do  --匹配两个最长连续且只含字母的\n    t[k] = v                                    --字符串，它们之间用等号连接\nend\nfor k, v in pairs(t) do\nprint (k,v)\nend\n\n--\x3eoutput\nto      Lua\nfrom    world\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br")])]),a("p",[s._v("此函数目前并不能被 LuaJIT 所 JIT 编译，而只能被解释执行。应 尽量 使用 ngx_lua 模块提供的 ngx.re.gmatch 等接口。")]),s._v(" "),a("h4",{attrs:{id:"string-rep-s-n"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-rep-s-n"}},[s._v("#")]),s._v(" string.rep(s, n)")]),s._v(" "),a("p",[s._v("返回字符串 s 的 n 次拷贝。")]),s._v(" "),a("h4",{attrs:{id:"string-sub-s-i-j"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-sub-s-i-j"}},[s._v("#")]),s._v(" string.sub(s, i [, j])")]),s._v(" "),a("p",[s._v("返回字符串 s 中，索引 i 到索引 j 之间的子字符串。当 j 缺省时，默认为 -1，也就是字符串 s 的最后位置。 i 可以为负数。当索引 i 在字符串 s 的位置在索引 j 的后面时，将返回一个空字符串。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.sub("Hello Lua", 4, 7))\nprint(string.sub("Hello Lua", 2))\nprint(string.sub("Hello Lua", 2, 1))    --看到返回什么了吗\nprint(string.sub("Hello Lua", -3, -1))\n\n--\x3eoutput\nlo L\nello Lua\n\nLua\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("如果你只是想对字符串中的单个字节进行检查，使用 string.char 函数通常会更为高效。")]),s._v(" "),a("h4",{attrs:{id:"string-gsub-s-p-r-n"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-gsub-s-p-r-n"}},[s._v("#")]),s._v(" string.gsub(s, p, r [, n])")]),s._v(" "),a("p",[s._v("将目标字符串 s 中所有的子串 p 替换成字符串 r。可选参数 n，表示限制替换次数。返回值有两个，第一个是被替换后的字符串，第二个是替换了多少次。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.gsub("Lua Lua Lua", "Lua", "hello"))\nprint(string.gsub("Lua Lua Lua", "Lua", "hello", 2)) --指明第四个参数\n\n--\x3eoutput\nhello hello hello   3\nhello hello Lua     2\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("此函数不能为 LuaJIT 所 JIT 编译，而只能被解释执行。一般我们推荐使用 ngx_lua 模块提供的 ngx.re.gsub 函数。")]),s._v(" "),a("h4",{attrs:{id:"string-reverse-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-reverse-s"}},[s._v("#")]),s._v(" string.reverse (s)")]),s._v(" "),a("p",[s._v("接收一个字符串 s，返回这个字符串的反转。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('print(string.reverse("Hello Lua"))  --\x3e output: auL olleH\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"原文地址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原文地址"}},[s._v("#")]),s._v(" 原文地址")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/string_library.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/string_library.html"),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=r.exports}}]);